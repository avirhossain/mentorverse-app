/**
 * @fileoverview Firestore Security Rules for the MentorVerse application.
 *
 * @description
 * This ruleset enforces a security model with two primary user roles: Mentees and Admins.
 * Mentors are data entities managed by Admins and do not have login credentials.
 * The rules are designed for security and performance, leveraging data denormalization to
 * avoid costly and complex lookups during authorization checks.
 *
 * @philosophy
 * - Core Philosophy: A hybrid model of user ownership and role-based access. Mentees have strict
 *   control over their personal profile data. Admins, identified by a document in the
 *   `/roles_admin` collection, have privileged access to manage application-wide data such as
 *   mentor profiles, sessions, and recommendations.
 *
 * @structure
 * - Data Structure: The data is organized into top-level collections. User-specific data is
 *   sandboxed under `/mentees/{menteeId}`. Shared and public data like `/mentors`, `/sessions`,
 *   and `/recommendations` are in separate top-level collections to facilitate different
 *   access patterns.
 *
 * @decisions
 * - Key Security Decisions:
 *   - Admin roles are determined by the existence of a document at `/roles_admin/{userId}`,
 *     which is a highly performant pattern. This collection is not client-readable or writable.
 *   - Mentees can only read shared documents (like sessions) if their UID is denormalized
 *     onto the document itself (e.g., a `menteeId` field).
 *   - Listing users is disallowed to protect user privacy.
 *   - Listing shared collections like `/sessions` is restricted to Admins to prevent data leakage.
 *     Mentees should fetch individual documents by known IDs.
 *
 * @denormalization
 * - Denormalization for Authorization: To ensure fast and secure access checks, documents in
 *   `/sessions` and `/recommendations` must contain a `menteeId` field. This allows rules to
 *   grant access to a mentee without needing to perform extra `get()` calls to other documents,
 *   which is critical for performance and scalability.
 *
 * @segregation
 * - Structural Segregation: Private mentee profiles (`/mentees`) are stored separately from
 *   publicly readable mentor profiles (`/mentors`). This clear separation simplifies rules and
 *   makes it easy to grant broad read access to mentor data while keeping mentee data strictly private.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the given userId.
     * This is the foundation of the user-ownership model.
     *
     * @param userId The UID to check against the authenticated user.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the document being accessed already exists in Firestore.
     * Crucial for securing update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Checks if the authenticated user is an administrator.
     * Admin status is granted by the existence of a document in the `roles_admin` collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Validates that the `menteeId` field of an incoming document matches the authenticated user's UID.
     * Used to ensure a mentee can only create documents for themselves.
     */
    function isMenteeOnIncomingDoc() {
      return isSignedIn() && request.resource.data.menteeId == request.auth.uid;
    }
    
    /**
     * Validates that the `menteeId` field of an existing document matches the authenticated user's UID.
     * Used to grant read access to existing documents.
     */
    function isMenteeOnExistingDoc() {
      return isSignedIn() && isExistingDoc() && resource.data.menteeId == request.auth.uid;
    }

    /**
     * Validates that the `id` field on an incoming user document matches the document's path ID (`menteeId`).
     * Enforces data consistency between the path and the document content on creation.
     */
    function newMenteeDataIsValid(menteeId) {
      return request.resource.data.id == menteeId;
    }

    /**
     * Ensures critical relational IDs cannot be changed after a document has been created.
     */
    function isMenteeIdImmutable() {
      return request.resource.data.menteeId == resource.data.menteeId;
    }

    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Rules for the `mentees` collection, which stores mentee profile data.
     * @path /mentees/{menteeId}
     * @allow A mentee (auth.uid=`user_abc`) creating their own profile at `/mentees/user_abc`. (create)
     * @deny Another user (auth.uid=`user_xyz`) trying to read the profile at `/mentees/user_abc`. (get)
     * @principle Restricts access to a user's own data tree, enforcing strict ownership.
     */
    match /mentees/{menteeId} {
      allow get: if isOwner(menteeId) || isAdmin();
      allow list: if isAdmin(); // Only admins can list all mentees.
      allow create: if isOwner(menteeId) && newMenteeDataIsValid(menteeId);
      allow update: if (isOwner(menteeId) || isAdmin()) && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();

      // Subcollection rules for transactions
      match /transactions/{transactionId} {
        allow get, list: if isOwner(menteeId) || isAdmin();
        allow create: if isOwner(menteeId) || isAdmin();
        allow update, delete: if isAdmin();
      }
    }

    /**
     * @description Rules for the `mentors` collection. Mentor profiles are readable by any
     *   user (mentees and guests), but can only be created or modified by an administrator.
     * @path /mentors/{mentorId}
     * @allow A signed-in mentee reading a mentor's profile at `/mentors/mentor_123`. (get)
     * @deny A non-admin user trying to create a new mentor profile. (create)
     * @principle Implements a "public-read, admin-write" pattern for application data.
     */
    match /mentors/{mentorId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();

      // Subcollection rules for payouts
      match /payouts/{payoutId} {
        allow get, list, create, update, delete: if isAdmin();
      }
    }

    /**
     * @description Rules for mentorship sessions. Sessions can be read by anyone to allow for public browsing.
     *   Creation is allowed for admins only. Updates are allowed by the mentee who booked it or an admin.
     * @path /sessions/{sessionId}
     * @allow A guest visitor listing all sessions on the main dashboard. (list)
     * @deny A mentee trying to create a session from scratch. (create)
     * @principle Enforces public read access while securing write operations. Admins manage content, users manage their own bookings.
     */
    match /sessions/{sessionId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }
    
    /**
     * @description Rules for reviews. Reviews can be read by anyone, but only created
     *   by the mentee associated with the session. Admins can delete reviews.
     * @path /reviews/{reviewId}
     */
    match /reviews/{reviewId} {
      allow get, list: if true;
      allow create: if isMenteeOnIncomingDoc();
      allow update: if false; // Reviews are immutable.
      allow delete: if isAdmin();
    }
    
    /**
     * @description Rules for tips. Tips are managed by admins but readable by all users.
     * @path /tips/{tipId}
     */
    match /tips/{tipId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rules for disbursements. Fully admin-controlled.
     * @path /disbursements/{disbursementId}
     */
    match /disbursements/{disbursementId} {
      allow get, list, create, update, delete: if isAdmin();
    }


    /**
     * @description Security rules for the admin roles collection.
     * @path /roles_admin/{userId}
     * @allow A rule check `exists(/databases/$(database)/documents/roles_admin/admin_uid)`. (internal)
     * @deny Any client attempting to read or write directly to this collection. (get, list, create, etc.)
     * @principle This collection is a lookup table for internal rule logic only. It must be locked
     *   down completely from all client-side access to prevent privilege escalation.
     */
    match /roles_admin/{userId} {
      allow read, write: if false;
    }
  }
}
